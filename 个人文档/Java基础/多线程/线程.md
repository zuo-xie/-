### 多线程并发条件下的数据安全问题
 ==服务器已经解决了多线程中的创建和启动，不需要我们来考虑。我们更加应该侧重的是，多线程状态下的数据安全。==
 
#### 存在多线程安全问题的条件
- 多线程并发
- 有共享数据
- 共享数据有修改行为

#### 解决方法
- 线程同步机制（线程排队）
    - 异步线程模型
        - 线程A和线程B分开进行
    - 同步线程模型
        - 线程B执行必须等待线程A执行结束

#### 三大Java变量
- 实例变量：在堆中
- 静态变量：在方法区中
- 局部变量：在栈中
    - 不会存在线程安全问题，因为局部变量永不共享。

实例变量在堆中，静态变量在方法区中，有且仅有一个。

> 堆和方法区都是多线程共享的，存在线程安全问题

#### ==synchronized关键字（锁）==
- 可以包含一个代码块
    - 更加灵活
- 在实例方法上使用
    - 一定锁`this`
    - 会锁整个方法体
- 在静态方法中使用
    - 表示找类锁，类锁永远只有一把（无论`new`多少个对象）

> 当多个并发线程访问同一个对象的`synchronized`代码块时，一个时间只会有一个线程执行，其他线程阻塞，但是可以访问其他非锁代码。

#### 守护线程
- Java线程分为两个大类
    - 用户线程
    - 守护线程（后台线程）
        - 垃圾回收线程（代表）
- 守护线程特点
    - 一个死循环线程
    - 所有用户线程结束，守护线程自动结束

> 主线程`mian`是一个用户线程

#### 定时器
- 定时器的作用
    - 间隔特定的时间，执行特定的程序
- `java.util.Timer`已经写好了一个定时器

#### 实现线程的三种方法：
- 继承`Thread`类
- 实现`Callable`接口
    - JDK8新特性
    - 有返回值
    - 效率低
- 实现`Runnable`接口（推荐）

#### 消费者和生产者